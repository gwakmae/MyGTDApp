@using MyGtdApp.Models
@using MyGtdApp.Services
@using Microsoft.AspNetCore.Components.Web
@inject ITaskService TaskService

<div class="task-node @(DraggedTaskId == Task.Id ? "is-ghost" : "")">

    <div class="task-node-self @DropIndicatorClass @InvalidClass @(IsSelected ? "is-selected" : "")"
         draggable="true"
         data-task-id="@Task.Id"
         @onclick="HandleClick"
         @ondragstart="() => OnTaskDragStart.InvokeAsync(Task.Id)"
         @ondragend="() => OnTaskDragEnd.InvokeAsync()"
         @ondrop:stopPropagation="true" @ondrop="HandleDrop"
         @ondragover:preventDefault="true" @ondragover:stopPropagation="true" @ondragover="HandleDragOver"
         @ondragleave="() => { dropIndicator = DropIndicator.None; dropInvalid = false; }">

        @if (Task.Children.Any())
        {
            <span class="expander" @onclick:stopPropagation="true" @onclick="ToggleExpand">@(Task.IsExpanded ? "▼" : "▶")</span>
        }
        else
        {
            <span class="expander-placeholder"></span>
        }

        <div class="task-card-wrapper">
            <TaskCard Task="Task"
                      OnTaskDeleted="() => OnTaskDeleted.InvokeAsync(Task.Id)"
                      OnTaskCompletedToggle="() => OnTaskCompletedToggle.InvokeAsync(Task.Id)"
                      OnTaskDoubleClick="() => OnTaskDoubleClick.InvokeAsync(Task.Id)" />
        </div>
        <button class="action-btn add-btn" @onclick:stopPropagation="true" @onclick="ToggleQuickAdd">+</button>
    </div>

    @if (Task.IsExpanded)
    {
        <div class="task-node-children">
            <div class="task-separator"></div>

            @foreach (var child in Task.Children
                                       .Where(c => !HideCompleted || !c.IsCompleted)
                                       .OrderBy(c => c.SortOrder))
            {
                <ProjectTaskNode @key="child.Id"
                                 Task="child"
                                 IsSelected="SelectedTaskIds.Contains(child.Id)"
                                 SelectedTaskIds="SelectedTaskIds"
                                 OnClick="args => OnClick.InvokeAsync(args)"
                                 OnTaskAdded="OnTaskAdded"
                                 OnTaskDeleted="OnTaskDeleted"
                                 OnTaskUpdated="OnTaskUpdated"
                                 OnTaskDragStart="OnTaskDragStart"
                                 OnTaskDragEnd="OnTaskDragEnd"
                                 OnTaskDropped="OnTaskDropped"
                                 OnTaskCompletedToggle="OnTaskCompletedToggle"
                                 OnTaskDoubleClick="OnTaskDoubleClick"
                                 DraggedTaskId="DraggedTaskId"
                                 HideCompleted="HideCompleted" />
            }

            @if (isAddingChild)
            {
                <div class="quick-add-container child-add">
                    <input @ref="quickAddInputRefForChild"
                           @bind="newChildTaskTitle"
                           @onkeyup="HandleChildQuickAddKeyUp"
                           @onblur="HandleChildQuickAddBlur"
                           placeholder="Add a sub-task..."
                           class="form-control" />
                </div>
            }
        </div>
    }
</div>

@code {
    /*------------- enum -------------*/
    public enum DropIndicator { None, Above, Inside, Below }

    /*------------- Parameters -------------*/
    [Parameter, EditorRequired] public TaskItem Task { get; set; } = default!;
    [Parameter] public int DraggedTaskId { get; set; }
    [Parameter] public bool HideCompleted { get; set; }

    [Parameter] public bool IsSelected { get; set; }
    [Parameter] public List<int> SelectedTaskIds { get; set; } = new();
    [Parameter] public EventCallback<(int taskId, MouseEventArgs e)> OnClick { get; set; }

    [Parameter] public EventCallback OnTaskAdded { get; set; }
    [Parameter] public EventCallback<int> OnTaskDeleted { get; set; }
    [Parameter] public EventCallback OnTaskUpdated { get; set; }
    [Parameter] public EventCallback<int> OnTaskDragStart { get; set; }
    [Parameter] public EventCallback OnTaskDragEnd { get; set; }
    [Parameter] public EventCallback<(int targetTaskId, DropIndicator position)> OnTaskDropped { get; set; }
    [Parameter] public EventCallback<int> OnTaskCompletedToggle { get; set; }
    [Parameter] public EventCallback<int> OnTaskDoubleClick { get; set; }

    /*------------- UI 상태 -------------*/
    private bool isAddingChild = false;
    private string newChildTaskTitle = "";
    private ElementReference quickAddInputRefForChild;
    private DropIndicator dropIndicator = DropIndicator.None;
    private bool dropInvalid = false;

    /*------------- CSS 클래스 계산 -------------*/
    private string DropIndicatorClass => dropIndicator switch
    {
        DropIndicator.Above => "drop-above",
        DropIndicator.Inside => "drop-inside",
        DropIndicator.Below => "drop-below",
        _ => ""
    };
    private string InvalidClass => dropInvalid ? "drop-invalid" : "";

    /*------------- 이벤트 핸들러 -------------*/
    private async Task HandleClick(MouseEventArgs e)
    {
        await OnClick.InvokeAsync((Task.Id, e));
    }

    private async Task ToggleExpand(MouseEventArgs e)
    {
        Task.IsExpanded = !Task.IsExpanded;
        await TaskService.UpdateTaskExpandStateAsync(Task.Id, Task.IsExpanded);
    }

    private async Task ToggleQuickAdd()
    {
        isAddingChild = !isAddingChild;
        if (isAddingChild)
        {
            await System.Threading.Tasks.Task.Delay(50);
            try { if (quickAddInputRefForChild.Context != null) await quickAddInputRefForChild.FocusAsync(); }
            catch (InvalidOperationException) { }
        }
    }

    private async Task HandleChildQuickAddKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(newChildTaskTitle))
        {
            await TaskService.AddTaskAsync(newChildTaskTitle, Task.Status, Task.Id);
            newChildTaskTitle = "";
            await OnTaskAdded.InvokeAsync();
            try { if (quickAddInputRefForChild.Context != null) await quickAddInputRefForChild.FocusAsync(); }
            catch (InvalidOperationException) { }
        }
        else if (e.Key == "Escape") { isAddingChild = false; }
    }

    private async Task HandleChildQuickAddBlur()
    {
        if (!string.IsNullOrWhiteSpace(newChildTaskTitle))
        {
            await TaskService.AddTaskAsync(newChildTaskTitle, Task.Status, Task.Id);
            await OnTaskAdded.InvokeAsync();
        }
        isAddingChild = false;
        newChildTaskTitle = "";
    }

    private void HandleDragOver(DragEventArgs e)
    {
        // 🔄 수정: 드래그 오버 시 선택된 여러 항목에 대한 유효성 검사
        if (SelectedTaskIds.Contains(Task.Id) || IsDescendantOfSelected(Task))
        {
            dropInvalid = true;
            dropIndicator = DropIndicator.None;
            return;
        }

        if (DraggedTaskId == Task.Id || IsDescendant(Task, DraggedTaskId))
        {
            dropInvalid = true;
            dropIndicator = DropIndicator.None;
            return;
        }

        dropInvalid = false;

        const double elementHeight = 38.0;
        var zone = elementHeight / 3.0;

        if (e.OffsetY < zone) dropIndicator = DropIndicator.Above;
        else if (e.OffsetY > elementHeight - zone) dropIndicator = DropIndicator.Below;
        else dropIndicator = DropIndicator.Inside;
    }

    private async Task HandleDrop()
    {
        if (dropInvalid)
        {
            dropIndicator = DropIndicator.None;
            dropInvalid = false;
            return;
        }

        if (dropIndicator != DropIndicator.None)
        {
            await OnTaskDropped.InvokeAsync((Task.Id, dropIndicator));
        }
        dropIndicator = DropIndicator.None;
    }

    private bool IsDescendant(TaskItem parent, int childId)
    {
        foreach (var child in parent.Children)
        {
            if (child.Id == childId) return true;
            if (IsDescendant(child, childId)) return true;
        }
        return false;
    }

    // 🆕 추가: 현재 작업이 선택된 항목들 중 하나의 자손인지 확인하는 메서드
    private bool IsDescendantOfSelected(TaskItem currentTask)
    {
        var parentId = currentTask.ParentId;
        while (parentId.HasValue)
        {
            if (SelectedTaskIds.Contains(parentId.Value))
            {
                return true;
            }
            // 실제 부모를 찾아서 계속 올라가야 하지만, 이 컴포넌트는 전체 트리를 모르므로
            // 이 정도의 방어 로직만으로도 대부분의 순환을 막을 수 있음.
            // 핵심 방어는 서버 사이드에서 이루어짐.
            parentId = null; // 단순화를 위해 한 단계만 체크
        }
        return false;
    }
}